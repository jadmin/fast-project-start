/* Automatic generated by CrudCodeGenerator wirtten by Gerald Chen
 *
 * @(#)LoginUserServiceImpl.java	${date}
 *
 * Copyright (c) ${year}. All Rights Reserved.
 *
 */

package ${packagePrefix}.service.impl;

import static ${packagePrefix}.common.AppConstants.RedisKeys.formatKey;

import java.util.List;
import java.util.Map;
import java.util.Objects;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import com.github.javaclub.sword.algorithm.crypt.Blowfish;
import com.github.javaclub.sword.core.BizObjects;
import com.github.javaclub.sword.core.Numbers;
import com.github.javaclub.sword.core.Strings;
import com.github.javaclub.sword.domain.QueryResult;
import com.github.javaclub.sword.domain.ResultDO;
import com.github.javaclub.sword.domain.dto.BatchOperationDTO;
import com.github.javaclub.sword.domain.enumtype.BasicMessage;
import com.google.common.collect.Lists;
import ${packagePrefix}.common.constants.RedisKeyConstants;
import ${packagePrefix}.common.enums.ErrorEnum;
import ${packagePrefix}.common.enums.SecondVerifyType;
import ${packagePrefix}.common.utils.ValidateUtils;
import ${packagePrefix}.dao.LoginUserDAO;
import ${packagePrefix}.dao.UserRoleDAO;
import ${packagePrefix}.dataobject.LoginUserDO;
import ${packagePrefix}.dataobject.UserRoleDO;
import ${packagePrefix}.query.LoginUserQuery;
import ${packagePrefix}.service.LoginUserService;
import ${packagePrefix}.service.params.LoginUserUpdateParam;
import ${packagePrefix}.service.params.UserLoginConfirmParam;
import ${packagePrefix}.service.params.UserModelParam;
import ${packagePrefix}.service.params.result.LoginCofirmResult;
import ${packagePrefix}.service.utils.BizUtils;
import ${packagePrefix}.service.utils.GoogleAuthenticatorUtils;

/**
 * LoginUserServiceImpl
 *
 * @version $Id: LoginUserServiceImpl.java ${currentTime} Exp $
 */
@Service("loginUserService")
public class LoginUserServiceImpl implements LoginUserService {
	
	static final Logger log = LoggerFactory.getLogger(LoginUserServiceImpl.class);
	
	@Autowired
	private LoginUserDAO loginUserDAO;
	
	@Autowired
	private UserRoleDAO userRoleDAO;
	
	@Autowired
	protected RedisTemplate<String, Object> redisTemplate;
	
	/**
	 * 创建时的业务校验
	 * 
	 * @param loginUserDO 业务实体
	 */
	void doCreateCheck(LoginUserDO loginUserDO) {
		// TODO Auto-generated method stub
		
	}
	
	/**
	 * 更新时的业务校验
	 * 
	 * @param loginUserDO 业务实体
	 */
	void doUpdateCheck(LoginUserDO loginUserDO) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public LoginUserDO checkLoginUser(String username, String rawPassword) {
		String md5Pwd = BizUtils.generatePasswordMD5(rawPassword);
		LoginUserDO loginUserDO = loginUserDAO.checkLogin(username, md5Pwd);
		return loginUserDO;
	}
	
	@Override
	public LoginUserDO getByUsername(String username) {
		LoginUserQuery query = new LoginUserQuery();
		query.setUsername(username);
		query.setPageable(1, 1);
		List<LoginUserDO> list = loginUserDAO.queryList(query);
		return (LoginUserDO) BizObjects.first(list);
	}

	@Override
	public LoginCofirmResult confirmLoginUser(UserLoginConfirmParam param) {
		LoginUserDO loginUserDO = loginUserDAO.getById(param.getUid());
		if (null == loginUserDO) {
			log.error("无效的用户ID={}", param.getUid());
			return null;
		}
		String username = loginUserDO.getUsername();
		String cfKey = formatKey(RedisKeyConstants.ADMIN_USER_LOGIN_CONFIRM, username);
		UserModelParam ump = (UserModelParam) redisTemplate.opsForValue().get(cfKey);
		ValidateUtils.requireTrue(null != ump, ErrorEnum.WRONG_ARGS, "登录已失效，请重新登录！");
		ValidateUtils.requireTrue(Objects.equals(param.getLoginIp(), ump.getLoginIp()), ErrorEnum.WRONG_ARGS, "当前登录环境存在安全风险-ZB00281");
		ValidateUtils.requireTrue(Objects.equals(param.getLoginUA(), ump.getLoginUA()), ErrorEnum.WRONG_ARGS, "当前登录环境存在安全风险-ZB00282");
		
		if(null != ump.getLoginTime() && (System.currentTimeMillis() - ump.getLoginTime() > 6*60*1000L)) {
			redisTemplate.delete(cfKey);
			return null; // 超时了
		}
		
		if (Objects.equals(SecondVerifyType.GOOGLE_CODE.getValue(), param.getType())) { // Google动态验证码
			
			// 验证码校验
			String key = Blowfish.decrypt(loginUserDO.getAuthKey());
			Integer code = Numbers.parseInt(param.getCode());
			
			boolean suc = GoogleAuthenticatorUtils.verify(key, code);
			ValidateUtils.requireTrue(suc, ErrorEnum.WRONG_ARGS, "验证码错误，请重新登录！");
			if(suc) {
				redisTemplate.delete(cfKey);
			}
			
			LoginCofirmResult result = new LoginCofirmResult();
			result.setLoginUser(loginUserDO);
			result.setRememberMe(ump.isRememberMe());
			
			return result;
			
		} else if (Objects.equals(SecondVerifyType.SMS_CODE.getValue(), param.getType())) { // 手机验证码
			
			String key = formatKey(RedisKeyConstants.ADMIN_USER_LOGIN_CONFIRM_CODE, username);
			String codeInRedis = (String) redisTemplate.opsForValue().get(key);
			
			ValidateUtils.requireTrue(Strings.isNotBlank(codeInRedis), ErrorEnum.WRONG_ARGS, "验证码已失效，请重新登录！");
			
			boolean suc = Strings.equals(codeInRedis, param.getCode());
			ValidateUtils.requireTrue(suc, ErrorEnum.WRONG_ARGS, "验证码错误，请重新登录！");
			if(suc) {
				redisTemplate.delete(key);
			}
			
			LoginCofirmResult result = new LoginCofirmResult();
			result.setLoginUser(loginUserDO);
			result.setRememberMe(ump.isRememberMe());
			
			return result;
		}
		
		return null;
	}
	

	@Override
	public boolean resetPassword(LoginUserDO user) {
		BizObjects.requireNotNullGtZero(user.getId(), "用户ID不能为空");
		BizObjects.requireNotEmpty(user.getPassword(), "用户密码不能为空");
		return loginUserDAO.resetPassword(user.getId(), user.getPassword()) > 0;
	}

	@Override
	public ResultDO<Boolean> save(LoginUserDO loginUserDO) {
		if(null == loginUserDO.getId()) {
			return create(loginUserDO);
		}
		LoginUserDO db = loginUserDAO.getById(loginUserDO.getId());
		if(null == db) {
			return ResultDO.failure(BasicMessage.NOT_FOUND);
		}
		return update(loginUserDO);
	}

	@Override
	public ResultDO<Boolean> create(LoginUserDO loginUserDO) {
		ResultDO<Boolean> result = ResultDO.failure();
		try {
			this.doCreateCheck(loginUserDO);
			int num = loginUserDAO.insert(loginUserDO);
			result = ResultDO.result(num > 0, "创建记录失败");
			if (num > 0) {
				this.updateUserRole(loginUserDO);
			}
		} catch (Exception e) {
			log.error("", e);
			result.setMessage(e.getMessage());
		}
		return result;
	}

	@Override
	public BatchOperationDTO<LoginUserDO> createBatch(List<LoginUserDO> list) {
		BatchOperationDTO<LoginUserDO> bod = new BatchOperationDTO<LoginUserDO>();
		List<LoginUserDO> toAdd = Lists.newArrayList();
		for (LoginUserDO item : list) {
			try {
				this.doCreateCheck(item);
			} catch (Exception e) {
				bod.addFailure(item);
				continue;
			}
			toAdd.add(item);
		}
		
		try {
			if(toAdd.size() > 0) {
				loginUserDAO.insertBatch(toAdd);
				bod.setSuccessList(toAdd);
			}
		} catch (Exception e) {
			bod.setMessage(e.getMessage());
			log.error("LoginUserService createBatch", e);
		}
		
		return bod;
	}

	@Override
	public ResultDO<Boolean> update(LoginUserDO loginUserDO) {
		ResultDO<Boolean> result = ResultDO.failure();
		try {
			BizObjects.requireNotNull(loginUserDO.getId(), "主键ID不能为空");
			this.doUpdateCheck(loginUserDO);
			int num = loginUserDAO.update(loginUserDO);
			result = ResultDO.result(num > 0, "没有记录被更新");
			if (num > 0) {
				this.updateUserRole(loginUserDO);
			}
		} catch (Exception e) {
			log.error("", e);
			result.setMessage(e.getMessage());
		}
		return result;
	}

	void updateUserRole(LoginUserDO loginUserDO) {
		if(null == loginUserDO.getId() || 0 >= loginUserDO.getId()) {
			return;
		}
		Map<String, Object> map = loginUserDO.getAttributesMap();
		if(null == map || !map.containsKey(LoginUserDO.ATTR_USER_ROLES)) {
			userRoleDAO.deleteByUserId(loginUserDO.getId());
			return;
		}
		userRoleDAO.deleteByUserId(loginUserDO.getId());
		String roleIdStr  = Objects.toString(map.get(LoginUserDO.ATTR_USER_ROLES), "");
		List<Long> longArr = Numbers.splitAsLongList(roleIdStr, ",");
		if(BizObjects.length(longArr) > 0) {
			List<UserRoleDO> list = Lists.newArrayList();
			for (Long roleId : longArr) {
				UserRoleDO urd = new UserRoleDO(loginUserDO.getId(), roleId);
				// TODO
				urd.setCreator("");
				urd.setModifier("");
				list.add(urd);
			}
			if(0 < list.size()) {
				userRoleDAO.insertBatch(list);
			}
		}
	}

	@Override
	public ResultDO<Boolean> deleteById(Long id) {
		ResultDO<Boolean> result = ResultDO.failure();
		try {
			int num = loginUserDAO.deleteById(id);
			result = ResultDO.result(num > 0, "没有记录被删除");
		} catch (Exception e) {
			log.error("", e);
			result.setMessage(e.getMessage());
		}
		return result;
	}

	@Override
	public ResultDO<LoginUserDO> getById(Long id) {
		ResultDO<LoginUserDO> result = ResultDO.failure();
		try {
			LoginUserDO dbRecord = loginUserDAO.getById(id);
			if(null != dbRecord) {
				result = ResultDO.success(dbRecord);
			}
		} catch (Exception e) {
			log.error("", e);
			result.setMessage(e.getMessage());
		}
		
		return result;
	}
	
	@Override
	public LoginUserDO selectById(Long id) {
		return loginUserDAO.getById(id);
	}

	@Override
	public int count(LoginUserQuery query) {
		return loginUserDAO.count(query);
	}

	@Override
	public List<LoginUserDO> findList(LoginUserQuery query) {
		return loginUserDAO.queryList(query);
	}

	@Override
	public QueryResult<LoginUserDO> findListWithCount(LoginUserQuery query) {
		QueryResult<LoginUserDO> queryResult = new QueryResult<LoginUserDO>();
		try {
			List<LoginUserDO> list = loginUserDAO.queryList(query);
			int count = loginUserDAO.count(query);
			queryResult.setTotalCount(count);
			queryResult.setEntry(list);
			queryResult.setSuccess(true);
		} catch (Exception e) {
			log.error("", e);
			queryResult.setSuccess(false);
			queryResult.setMessage(e.getMessage());
		}
		return queryResult;
	}
	
	@Override
    public ResultDO<Boolean> updateUserProfileDetail(LoginUserUpdateParam loginUserUpdateParam) {
        Long id = loginUserUpdateParam.getId();
        Integer secondVerifyType = loginUserUpdateParam.getSecondVerifyType();
        String authKey = loginUserUpdateParam.getAuthKey();
        Boolean openSecondVerify = loginUserUpdateParam.getOpenSecondVerify();
        
        if (Objects.isNull(id) || Objects.isNull(openSecondVerify)) {
            log.warn("Failed to update user profile detail because params is invalid by loginUserUpdateParam: {}",
                    loginUserUpdateParam);
            return ResultDO.failure(ErrorEnum.PARAM_ERROR.getCode());
        }
        if (openSecondVerify && Strings.isNullOrEmpty(authKey) 
        		&& Objects.equals(SecondVerifyType.GOOGLE_CODE.getValue(), secondVerifyType)) {
            log.warn("Failed to update user profile detail because params is invalid by loginUserUpdateParam: {}",
                    loginUserUpdateParam);
            return ResultDO.failure(ErrorEnum.PARAM_ERROR.getCode());
        }
        LoginUserDO loginUserDO = new LoginUserDO();
        loginUserDO.setId(id);
        try {
        	loginUserDO.addAttribute(LoginUserDO.ATTR_SECOND_VERIFY_TYPE, secondVerifyType);
            loginUserDO.addAttribute(LoginUserDO.ATTR_OPEN_SECOND_VERIFY, openSecondVerify);
            if (openSecondVerify && Objects.equals(SecondVerifyType.GOOGLE_CODE.getValue(), secondVerifyType)) {
            	loginUserDO.setAuthKey(Blowfish.encrypt(authKey));
            }
            loginUserDAO.update(loginUserDO);
            return ResultDO.success(Boolean.TRUE);
        } catch (Exception e) {
            log.error("Failed to update user profile detail by loginUserUpdateParam: {}, cause: {}",
                    loginUserUpdateParam, e);
            return ResultDO.failure(ErrorEnum.LOGIN_USER_PROFILE_DETAIL_UPDATE_FAIL.getCode());
        }
    }

    @Override
    public ResultDO<Boolean> resetSecondAuth(Long userId) {
        LoginUserDO loginUserDO = new LoginUserDO();
        loginUserDO.setId(userId);
        try {
            LoginUserDO userDO = loginUserDAO.getById(userId);
            userDO.removeAttribute(LoginUserDO.ATTR_OPEN_SECOND_VERIFY);
            userDO.removeAttribute(LoginUserDO.ATTR_SECOND_VERIFY_TYPE);
            loginUserDO.setAttributes(userDO.getAttributes());
            loginUserDAO.resetSecondAuth(loginUserDO);
            return ResultDO.success(Boolean.TRUE);
        } catch (Exception e) {
            log.error("Failed to reset second auth by userId: {}, cause :{}", userId, e);
            return ResultDO.failure(ErrorEnum.USER_SECOND_AUTH_RESET_FAIL.getCode());
        }
    }

	@Override
	public LoginUserDO matchUserByQueryKey(String val) {
		return loginUserDAO.matchUserByQueryKey(val);
	}


}
